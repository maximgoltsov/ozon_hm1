// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: productType.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ProductTypeClient is the client API for ProductType service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProductTypeClient interface {
	ProductTypeCreate(ctx context.Context, in *ProductTypeCreateRequest, opts ...grpc.CallOption) (*ProductTypeCreateResponse, error)
	ProductTypeDelete(ctx context.Context, in *ProductTypeDeleteRequest, opts ...grpc.CallOption) (*ProductTypeDeleteResponse, error)
	ProductTypeUpdate(ctx context.Context, in *ProductTypeUpdateRequest, opts ...grpc.CallOption) (*ProductTypeUpdateResponse, error)
	ProductTypeGet(ctx context.Context, in *ProductTypeGetRequest, opts ...grpc.CallOption) (*ProductTypeGetResponse, error)
	ProductTypeList(ctx context.Context, in *ProductTypeListRequest, opts ...grpc.CallOption) (*ProductTypeListResponse, error)
}

type productTypeClient struct {
	cc grpc.ClientConnInterface
}

func NewProductTypeClient(cc grpc.ClientConnInterface) ProductTypeClient {
	return &productTypeClient{cc}
}

func (c *productTypeClient) ProductTypeCreate(ctx context.Context, in *ProductTypeCreateRequest, opts ...grpc.CallOption) (*ProductTypeCreateResponse, error) {
	out := new(ProductTypeCreateResponse)
	err := c.cc.Invoke(ctx, "/ozon.dev.mc2.api.ProductType/ProductTypeCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productTypeClient) ProductTypeDelete(ctx context.Context, in *ProductTypeDeleteRequest, opts ...grpc.CallOption) (*ProductTypeDeleteResponse, error) {
	out := new(ProductTypeDeleteResponse)
	err := c.cc.Invoke(ctx, "/ozon.dev.mc2.api.ProductType/ProductTypeDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productTypeClient) ProductTypeUpdate(ctx context.Context, in *ProductTypeUpdateRequest, opts ...grpc.CallOption) (*ProductTypeUpdateResponse, error) {
	out := new(ProductTypeUpdateResponse)
	err := c.cc.Invoke(ctx, "/ozon.dev.mc2.api.ProductType/ProductTypeUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productTypeClient) ProductTypeGet(ctx context.Context, in *ProductTypeGetRequest, opts ...grpc.CallOption) (*ProductTypeGetResponse, error) {
	out := new(ProductTypeGetResponse)
	err := c.cc.Invoke(ctx, "/ozon.dev.mc2.api.ProductType/ProductTypeGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productTypeClient) ProductTypeList(ctx context.Context, in *ProductTypeListRequest, opts ...grpc.CallOption) (*ProductTypeListResponse, error) {
	out := new(ProductTypeListResponse)
	err := c.cc.Invoke(ctx, "/ozon.dev.mc2.api.ProductType/ProductTypeList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductTypeServer is the server API for ProductType service.
// All implementations must embed UnimplementedProductTypeServer
// for forward compatibility
type ProductTypeServer interface {
	ProductTypeCreate(context.Context, *ProductTypeCreateRequest) (*ProductTypeCreateResponse, error)
	ProductTypeDelete(context.Context, *ProductTypeDeleteRequest) (*ProductTypeDeleteResponse, error)
	ProductTypeUpdate(context.Context, *ProductTypeUpdateRequest) (*ProductTypeUpdateResponse, error)
	ProductTypeGet(context.Context, *ProductTypeGetRequest) (*ProductTypeGetResponse, error)
	ProductTypeList(context.Context, *ProductTypeListRequest) (*ProductTypeListResponse, error)
	mustEmbedUnimplementedProductTypeServer()
}

// UnimplementedProductTypeServer must be embedded to have forward compatible implementations.
type UnimplementedProductTypeServer struct {
}

func (UnimplementedProductTypeServer) ProductTypeCreate(context.Context, *ProductTypeCreateRequest) (*ProductTypeCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProductTypeCreate not implemented")
}
func (UnimplementedProductTypeServer) ProductTypeDelete(context.Context, *ProductTypeDeleteRequest) (*ProductTypeDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProductTypeDelete not implemented")
}
func (UnimplementedProductTypeServer) ProductTypeUpdate(context.Context, *ProductTypeUpdateRequest) (*ProductTypeUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProductTypeUpdate not implemented")
}
func (UnimplementedProductTypeServer) ProductTypeGet(context.Context, *ProductTypeGetRequest) (*ProductTypeGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProductTypeGet not implemented")
}
func (UnimplementedProductTypeServer) ProductTypeList(context.Context, *ProductTypeListRequest) (*ProductTypeListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProductTypeList not implemented")
}
func (UnimplementedProductTypeServer) mustEmbedUnimplementedProductTypeServer() {}

// UnsafeProductTypeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductTypeServer will
// result in compilation errors.
type UnsafeProductTypeServer interface {
	mustEmbedUnimplementedProductTypeServer()
}

func RegisterProductTypeServer(s grpc.ServiceRegistrar, srv ProductTypeServer) {
	s.RegisterService(&ProductType_ServiceDesc, srv)
}

func _ProductType_ProductTypeCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductTypeCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductTypeServer).ProductTypeCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ozon.dev.mc2.api.ProductType/ProductTypeCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductTypeServer).ProductTypeCreate(ctx, req.(*ProductTypeCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductType_ProductTypeDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductTypeDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductTypeServer).ProductTypeDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ozon.dev.mc2.api.ProductType/ProductTypeDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductTypeServer).ProductTypeDelete(ctx, req.(*ProductTypeDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductType_ProductTypeUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductTypeUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductTypeServer).ProductTypeUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ozon.dev.mc2.api.ProductType/ProductTypeUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductTypeServer).ProductTypeUpdate(ctx, req.(*ProductTypeUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductType_ProductTypeGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductTypeGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductTypeServer).ProductTypeGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ozon.dev.mc2.api.ProductType/ProductTypeGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductTypeServer).ProductTypeGet(ctx, req.(*ProductTypeGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductType_ProductTypeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductTypeListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductTypeServer).ProductTypeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ozon.dev.mc2.api.ProductType/ProductTypeList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductTypeServer).ProductTypeList(ctx, req.(*ProductTypeListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProductType_ServiceDesc is the grpc.ServiceDesc for ProductType service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProductType_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ozon.dev.mc2.api.ProductType",
	HandlerType: (*ProductTypeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProductTypeCreate",
			Handler:    _ProductType_ProductTypeCreate_Handler,
		},
		{
			MethodName: "ProductTypeDelete",
			Handler:    _ProductType_ProductTypeDelete_Handler,
		},
		{
			MethodName: "ProductTypeUpdate",
			Handler:    _ProductType_ProductTypeUpdate_Handler,
		},
		{
			MethodName: "ProductTypeGet",
			Handler:    _ProductType_ProductTypeGet_Handler,
		},
		{
			MethodName: "ProductTypeList",
			Handler:    _ProductType_ProductTypeList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "productType.proto",
}
